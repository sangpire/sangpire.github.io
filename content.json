{"pages":[],"posts":[{"title":"Sites","permalink":"http://sangpire.github.io/2017/03/26/Sites/","text":"http://realfavicongenerator.net/Favicon 생성해주는 웹 서비스"},{"title":"Hello World","permalink":"http://sangpire.github.io/2017/03/25/hello-world/","text":"hexo 를 처음 시작할 때 기본적으로 존재하는 글. Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"socat 명령어","permalink":"http://sangpire.github.io/2016/10/07/socat/","text":"로컬 파일을 서버로 전송하려고 하니 socat이 가장 먼저 생각이 났습니다.socat 은 Multipurpose relay (SOcket CAT) 이라고 합니다. ‘다목적 중계기’ !? 원래 사용한적이 있던 명령어지만 또 까먹어서 사용 방법을 찾아봅니다. 우선 tldr 로 사용방법을 살펴봅니다. 1234567891011121314$ tldr socatsocatMultipurpose relay (SOcket CAT).- Listen to a port, wait for an incoming connection and transfer data to STDIO: socat - TCP-LISTEN:8080,fork- Create a connection to a host and port, transfer data in STDIO to connected host: socat - TCP4:www.domain.com:80- Forward incoming data of a local port to another host and port: socat TCP-LISTEN:80,fork TCP4:www.domain.com:80 난 파일을 전송하고 싶은건데 큰 도움이 안되니, man 페이지를 살펴봅니다. 우선 OPTIONS 중 -u Uses unidirectional mode. The first address is only used for reading, and the second address is only used for writing (example). 단방향 모드, 첫번째 주소 -&gt; 두번째 주소 -U Uses unidirectional mode in reverse direction. The first address is only used for writing, and the second address is only used for reading. 단방향 모드, 첫번째 주소 &lt;- 두번째 주소 다음은, ADDRESS TYPES 중주소를 작성하는 방식들 우선 ‘파일’ 관련된 녀석들만 읽어봅니다. 첫번째, CREATE:&lt;filename&gt; ADDRESS TYPE Opens &lt;filename&gt; with creat() and uses the file descriptor for writing. This address type requires write-only context, because a file opened with creat cannot be read from. 쓰기 전용으로만 쓰일 수 있는 주소인가 봅니다. Flags like O_LARGEFILE cannot be applied. If you need them use OPEN with options create,create. create,create 오타인가?.. &lt;filename&gt; must be a valid existing or not existing path. If &lt;filename&gt; is a named pipe, creat() might block; if &lt;filename&gt; refers to a socket, this is an error. Option groups: FD,REG,NAMED Useful options: mode, user, group, unlink-early, unlink-late, append See also: OPEN, GOPEN 두번째, GOPEN:&lt;filename&gt; ADDRESS TYPE (Generic open) This address type tries to handle any file system entry except directories usefully. &lt;filename&gt; may be a relative or absolute path.If it already exists, its type is checked. In case of a UNIX domain socket, socat connects; if connecting fails, socat assumes a datagram socket and uses sendto() calls.If the entry is not a socket, socat opens it applying the O_APPEND flag.If it does not exist, it is opened with flag O_CREAT as a regular file(example). Option groups: FD,REG,SOCKET,NAMED,OPEN See also: OPEN, CREATE, UNIX-CONNECT directories 를 제외하고 일반적인 파일 시스템 엔트리(= 무엇을 의미하는 걸까요?) 에 유용하다고 하네요. &lt;filename&gt; 이 존재하면 뒤에 내용을 덧붙히고, 없으면 만들어주나 봅니다. 세번째, OPEN:&lt;filename&gt; ADDRESS TYPE Opens &lt;filename&gt; using the open() system call (example). This operation fails on UNIX domain sockets. Note: This address type is rarly useful in bidirectional mode. Option groups: FD,REG,NAMED,OPEN Useful options: creat, excl, noatime, nofollow, append, rdonly, wronly, lock, readbytes, ignoreeof See also: CREATE, GOPEN, UNIX-CONNECT 오타 발견 ‘rarly’!! 양방향 모드에선 거의 유용하지 않다고 합니다. 결론결과적으로 파일을 보내고자 하는 서버와 클라이언트 에서 실행한 명령어는 다음과 같습니다. 서버에서, GOPEN을 사용했지만, OPEN 을 써도 될 듯.1$ socat -u GOPEN:./source.file TCP:192.168.0.1:9999 클라이언트에서,1$ socat -u TCP-LISTEN:9999 CREATE:target.file"},{"title":"Velocity Toolbox 생성과정.","permalink":"http://sangpire.github.io/2016/05/16/velocity-spring-toolbox/","text":""},{"title":"How to obtain a current user locale","permalink":"http://sangpire.github.io/2016/05/16/SpringFramework/","text":"처음에는 ServletRequest 에서 가져왔다. 1Locale locale = request.getLocale(); 그런데 이 녀석이, LocaleResolver 빈이 설정한 값을 제대로 가져오지 못하더라는; 아래 스택오버플로우 답변처럼 하니 잘 됨. 1Locale locale = LocaleContextHolder.getLocale(); 쓰레드 로컬에서 가져온거라고 하는데,.. 쓰레드 로컬에 대해서도 좀 알아봐야겠다. Stackoverflow"},{"title":"When proxying is enabled you need to use interfaces, not implementations.","permalink":"http://sangpire.github.io/2016/05/15/spring-autowiring-fail-with-Transactional/","text":"@Service 빈을, WebSecurityConfigurerAdapter 을 상속한 코드에서 @Autowired 하고 있는 상황이였음. @Service 빈에 한 메서드에 @Transactional 을 추가하자 @Autowired 가 실패하기 시작함. 인터넷 검색해 보니, 스택오버플로에서 처리 방법을 알게 됨. When proxying is enabled you need to use interfaces, not implementations. 즉, Proxying 으로 동작하게 되면, interface 를 써야지, implementation 을 쓰면 안된다는 말, 코드를 수정해 보니 우선 잘 된다. 음 자세한건 좀 더 찾아봐야지… Stackoverflow"},{"title":"CSS","permalink":"http://sangpire.github.io/2016/04/19/css/","text":"word-spacing단어 사이 여백을 조절하는 CSS 도 있구나,… word-spacing - CSS MDN 페이지를 읽어보자."},{"title":"Mac OS","permalink":"http://sangpire.github.io/2013/08/15/macTips/","text":"동일한 어플리케이션 사이는 Command + Tab 이 동작하지 않아요.Mac OS X 에서 어플리케이션 간에 이동하는 단축키는 Command + Tab 입니다. 그런데 이 녀석, 동일한 어플리케이션이 여러 창으로 띄워져 있는 경우 그 창 사이에서는 단축키가 먹지 않습니다. 동일한 어플리케이션 사이를 이동하는 단축키는 따로 있더군요.바로, Command + ` 입니다"},{"title":"nvm 으로 node 설치하기.","permalink":"http://sangpire.github.io/2013/08/11/node-install/","text":"ruby 에 rvm 이 있고, perl 에 perlbrew 가 있는 것 처럼 node 에도 nvm 이 있더군요. 우선 홈페이지에 설명대로, 설치 스크립트를 실행하였습니다. 1curl https://raw.github.com/creationix/nvm/master/install.sh | sh 설치하고 나면, .bash_profile 에 다음과 같은 명령이 추가된 것을 확인할 수 있습니다. 1[[ -s /Users/sangpire/.nvm/nvm.sh ]] &amp;&amp; . /Users/sangpire/.nvm/nvm.sh # This loads NVM 그리고, 설정 파일 적용을 위해, 터미널을 재시작 본격적인 nvm 실행.우선 nvm 명령을 실행하면, 다음과 같은 도움말이 나타납니다. 1234567891011121314151617181920212223242526rosebook:Vibration sangpire$ nvmNode Version ManagerUsage: nvm help Show this message nvm install [-s] &lt;version&gt; Download and install a &lt;version&gt; nvm uninstall &lt;version&gt; Uninstall a version nvm use &lt;version&gt; Modify PATH to use &lt;version&gt; nvm run &lt;version&gt; [&lt;args&gt;] Run &lt;version&gt; with &lt;args&gt; as arguments nvm ls List installed versions nvm ls &lt;version&gt; List versions matching a given description nvm ls-remote List remote versions available for install nvm deactivate Undo effects of NVM on current shell nvm alias [&lt;pattern&gt;] Show all aliases beginning with &lt;pattern&gt; nvm alias &lt;name&gt; &lt;version&gt; Set an alias named &lt;name&gt; pointing to &lt;version&gt; nvm unalias &lt;name&gt; Deletes the alias named &lt;name&gt; nvm copy-packages &lt;version&gt; Install global NPM packages contained in &lt;version&gt; to current versionExample: nvm install v0.4.12 Install a specific version number nvm use 0.2 Use the latest available 0.2.x release nvm run 0.4.12 myApp.js Run myApp.js using node v0.4.12 nvm alias default 0.4 Auto use the latest installed v0.4.x versionrosebook:Vibration sangpire$ 이 명령중, ls-remote 로 설치 가능한 버전을 확인하고, install 로 설치하면 완료. 1nvm install 0.10 현재 ls-remote 명령을 실행하면, v0.11.5 까지 나타나지만, 설치해서 npm 으로 모듈을 설치하려 하니 오류가 좀 있어서, v0.10 을 설치 했습니다. (홈페이지에도, 현재 버전이 v0.10.15 라고 나오더군요.) 설치 하고, v0.10.x 를 사용하겠다고 아래와 같이 입력하면 설정 완료. 1nvm use 0.10 설명 마지막에 있는 것처럼 alias 도 설정해 보고, 1nvm alias default 0.11 재미난 모듈들을 설치해보면 끝!."},{"title":"Bash","permalink":"http://sangpire.github.io/2013/08/11/Bash/","text":"트위터 지인의 리트윗 중, 관심있던 내용을 정리해 놓은 글 Bash Configurations Demystified을 봤습니다. 그 중 제 컴퓨터와 관련이 있는, OS X 에 관한 것만 살짝 살펴봤습니다. 블로그에서 살펴본 내용,OS X 을 처음 설치하면, .bashrc 파일과, .bash_profile 파일이 존재합니다. OS X 은 SSH로 PC에 접근하던, 터미널 프로그램을 실행하던, 기본적으로 로그인 쉘을 시작합니다. OS X 은 기본적으로, .bash_profile을 먼저 실행합니다.그리고, .bash_profile 에는 아래와 같은 내용이 포함되어 있습니다. 1[[ -s ~/.bashrc ]] &amp;amp;&amp;amp; source ~/.bashrc 즉, .bashrc는 .bash_profile에 의해 실행된다는 이야기. 하지만,위 내용으로 블로그에 요약을 해 놓으려고 확인 겸 새로운 계정을 생성해 보았더니, .bash_profile 도, .bashrc 도 없더군요. 제 짧은 영어 탓일 지도 모릅니다. 그래서 좀더 살펴보았습니다.그래서 Bash 매뉴얼 페이지(man)를 살펴 봤습니다. 그 안에는 아래와 같은 내용이 있더군요. When bash is invoked as an interactive login shell, or as a non-interactive shell with the --login option, it first reads and executes commands from the file /etc/profile, if that file exists. After reading that file, it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile, in that order, and reads and executes commands from the first one that exists and is readable. 해석해 보면,Bash 가 대화형(=interactive) 로그인 쉘 이나 --login 옵션과 함께 비대화형(=interactive) 쉘로 로 생성되어질 때, 처음으로 /etc/profile 파일을 읽고 실행하게 됩니다. 파일을 실행 한 다음 ~/.bash_profile, ~/.bash_login 그리고 ~/.profile 파일 중 을 순서대로 파일을 찾아보고 그 중 처음으로 존재하고, 읽을 수 있는 파일만 읽고 실행하게 됩니다. 위에 있는 파일을 하나씩 만들고 지우면서 실행해 보니 정말 메뉴얼 페이지 대로 동작하더군요. 123Last login: Sun Aug 11 00:24:35 on ttys000Hi This is .bash_profilerosebook:~ sangpire$ 그렇더라구요. :)"},{"title":"다음엔","permalink":"http://sangpire.github.io/2012/11/05/for-next-time/","text":"코드를 작성하기 전에, 머릿속에서 타당한 구조가 떠오르기 전에, 코드부터 작성하는 버릇은 고쳐야겠다, 2012. 11. 5"},{"title":"Groovy, DB에서 특정 값으로 시작 하는 녀석들을 세어보고 싶을 때.","permalink":"http://sangpire.github.io/2012/10/29/groovy/","text":"오늘 일을 하다, 몇몇 테이블에서 url 컬럼에 시작값이 http://www.daum.net 또는 http://www.naver.com 또는 http://www.nate.com 인 녀석들의 통계를 구하는 작업을 했습니다.(여기서 컬럼명 url, 값 네이버, 다음, 네이트 등등은 실제 데이터는 아닙니다.) 이 작업은 꽤 많은 테이블에 반복적인 쿼리를 날려야 하는 일로, 쉽지않은 방법으로 아래와 같은 그루비(=Groovy) 코드를 만들었습니다. @GrabConfig(systemClassLoader=true) @Grab(group='mysql', module='mysql-connector-java', version='5.1.21') import groovy.sql.Sql def db1 = Sql.newInstance('jdbc:mysql://DB_SERVER1:3306/db1','ID', 'Password', 'com.mysql.jdbc.Driver') def db2 = Sql.newInstance('jdbc:mysql://DB_SERVER2:3306/db2','ID', 'Password', 'com.mysql.jdbc.Driver') def db1_tables = [ 'T001', 'T002'] def db2_tables = [ 'T003', 'T004'] countEmbedTypes = { bbs, tables -&gt; tables.each{ table -&gt; bbs.eachRow( \"\"\" SELECT SUM(1) AS 'Total', SUM(IF (url LIKE \"http://www.daum.net%\", 1, 0)) AS 'daum', SUM(IF (url LIKE \"http://www.naver.com%\", 1, 0)) AS 'naver', SUM(IF (url LIKE \"http://www.nate.com/%\", 1, 0)) AS 'nate' FROM \"\"\" + table ){ def total = toInt(it.Total) def daum = toInt(it.daum) def naver = toInt(it.naver) def nate = toInt(it.nate) printf ( \"| %6s | %6s | %6s | %6s | %6s | \\n\", [table, total, daum, naver, nate]) } } } def toInt(i) { return (i == null) ? 0 : i.toInteger() } countUrlTypes(db1, db1_tables) countUrlTypes(db2, db2_tables) 첫 번째 난관은 SQL 쿼리를 만드는 일, 이건 StackOverflow 에서 해답을 구했습니다. 아래와 같은 형태로. 몇번 실행해보니 원하던 값이 나오더군요. SELECT SUM(1) AS 'Total', SUM(IF (url LIKE \"http://www.daum.net%\", 1, 0)) AS 'daum', SUM(IF (url LIKE \"http://www.naver.com%\", 1, 0)) AS 'naver', SUM(IF (url LIKE \"http://www.nate.com/%\", 1, 0)) AS 'nate' FROM YOUR_TABLE 두번째 난관은 그루비에서 MySQL 서버에 연결하는 방법. import groovy.sql.Sql def db1 = Sql.newInstance('jdbc:mysql://DB_SERVER1:3306/db1','ID', 'Password', 'com.mysql.jdbc.Driver') 그루비 홈페이지에서 위와 같은 코드는 쉽게 발견할 수 있었는데, 문제는 예제 코드를 실행하면, com.mysql.jdbc.Driver 관련 클래스를 찾을 수 없다는 오류 메시지. 혹시나해서 Maven Classpath를 Groovy에서 쓸수 있는 방법을 찾다가. @Grab 이란 표현으로 메이븐 저장소의 라이브러리를 읽어 올 수 있다는 방법을 알게 되었습니다. @Grab(group='mysql', module='mysql-connector-java', version='5.1.21') 그리고, 데이터베이스 드라이버의 경우, @GrabConfig 에서 systemClassLoader을 true로 설정해야 한다고 합니다. @GrabConfig(systemClassLoader=true) 위 systemClassLoader 설정은 그루비 API 페이지에, 아래와 같은 설명으로 되어 있는데, 내용은 잘 이해가 안되네여.. ‘포도’를 로딩하다니,… Set to true if you want to use the system classloader when loading the grape. This is normally only required when a core Java class needs to reference the grabbed classes, e.g. for a database driver accessed using DriverManager. 그 외에도 그루비 클로져도 찾아 쓰고, 함수도 찾아 써봐서, 생각보다 어렵게 하지만 재미있는 스크립트를 만들 수 있었습니다."},{"title":"vim","permalink":"http://sangpire.github.io/2012/10/15/vim/","text":"설정과 관련된 내용들.자동 줄바꿈이 안되게 하려면, 2012. 10. 15 긴 로그 파일의 경우 자동 줄바꿈은 위 아래줄 형식이 있는 로그의 경우, 한눈에 살펴보기 쉽지 않다.이럴때는, 자동 줄바꿈(wrap) 옵션을 끄면 된다. 1set nowrap"}]}